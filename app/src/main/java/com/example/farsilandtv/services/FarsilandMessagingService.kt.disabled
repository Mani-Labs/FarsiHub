package com.example.farsilandtv.services

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import android.util.Log
import androidx.core.app.NotificationCompat
import com.example.farsilandtv.R
import com.example.farsilandtv.VideoPlayerActivity
import com.example.farsilandtv.data.database.AppDatabase
import com.example.farsilandtv.utils.FCMTokenManager
import com.example.farsilandtv.utils.NotificationHelper
import com.google.firebase.crashlytics.FirebaseCrashlytics
import com.google.firebase.messaging.FirebaseMessagingService
import com.google.firebase.messaging.RemoteMessage
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.Calendar

/**
 * Firebase Cloud Messaging service for FarsilandTV
 * Handles push notifications for new episodes and seasons
 * Feature #9 - Push Notifications
 *
 * Message Payload Format:
 * {
 *   "type": "new_episode" | "new_season" | "weekly_digest",
 *   "series_title": "Series Name",
 *   "episode_title": "Episode Name", // for new_episode
 *   "season_number": "1", // for new_season
 *   "content_id": "123", // for deep linking
 *   "thumbnail_url": "https://..." // optional
 * }
 */
class FarsilandMessagingService : FirebaseMessagingService() {

    companion object {
        private const val TAG = "FarsilandMessaging"
        private const val CHANNEL_ID_NEW_EPISODES = "farsiland_new_episodes"
        private const val CHANNEL_ID_NEW_SEASONS = "farsiland_new_seasons"
        private const val CHANNEL_ID_WEEKLY_DIGEST = "farsiland_weekly_digest"
        private const val NOTIFICATION_ID_NEW_EPISODE = 1001
        private const val NOTIFICATION_ID_NEW_SEASON = 1002
        private const val NOTIFICATION_ID_WEEKLY_DIGEST = 1003
    }

    private val database by lazy { AppDatabase.getDatabase(applicationContext) }
    private val notificationHelper by lazy { NotificationHelper(applicationContext) }
    private val tokenManager by lazy { FCMTokenManager(applicationContext) }
    private val serviceScope = CoroutineScope(Dispatchers.IO)

    override fun onCreate() {
        super.onCreate()
        createNotificationChannels()
    }

    /**
     * Called when a new FCM registration token is generated
     * Token is saved locally and ready for backend registration when available
     *
     * Current Implementation:
     * - ✅ Token saved to local storage (SharedPreferences)
     * - ✅ Ready for retrieval by backend when implemented
     * - ⚠️ No backend registration yet (see FCMTokenManager for details)
     * - ✅ (M4) Token logged to Crashlytics for debugging
     *
     * @param token The new FCM registration token
     * @see FCMTokenManager for backend integration instructions
     */
    override fun onNewToken(token: String) {
        super.onNewToken(token)
        Log.d(TAG, "New FCM token received")
        Log.d(TAG, "Token (first 20 chars): ${token.take(20)}...")

        // Save token locally for future backend registration
        tokenManager.saveToken(token)

        // Get diagnostic info
        val diagnostics = tokenManager.getDiagnosticInfo()
        Log.d(TAG, "Token status: $diagnostics")

        // M4: Log token to Crashlytics for debugging
        try {
            FirebaseCrashlytics.getInstance().apply {
                setCustomKey("fcm_token", token)
                log("FCM token refreshed")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to log FCM token to Crashlytics: ${e.message}")
        }

        // TODO: When backend is available, uncomment the following:
        // serviceScope.launch {
        //     try {
        //         val success = tokenManager.registerWithBackend(token)
        //         if (success) {
        //             Log.i(TAG, "FCM token successfully registered with backend")
        //         } else {
        //             Log.w(TAG, "FCM token registration failed - will retry later")
        //         }
        //     } catch (e: Exception) {
        //         Log.e(TAG, "Error during token registration", e)
        //     }
        // }
    }

    /**
     * Called when a message is received from Firebase
     */
    override fun onMessageReceived(message: RemoteMessage) {
        super.onMessageReceived(message)

        Log.d(TAG, "Message received from: ${message.from}")

        // Check if message contains data payload
        if (message.data.isNotEmpty()) {
            Log.d(TAG, "Message data payload: ${message.data}")

            // Process message in background
            serviceScope.launch {
                handleDataMessage(message.data)
            }
        }

        // Check if message contains notification payload
        message.notification?.let {
            Log.d(TAG, "Message notification: ${it.title} - ${it.body}")
            // FCM already displays these automatically, but we can customize
        }
    }

    /**
     * Handle data messages based on type
     * M4: Added error logging to Crashlytics
     */
    private suspend fun handleDataMessage(data: Map<String, String>) {
        val type = data["type"] ?: return

        try {
            // Check notification preferences and quiet hours
            if (!shouldShowNotification(type)) {
                Log.d(TAG, "Notification blocked by user preferences or quiet hours")
                return
            }

            withContext(Dispatchers.Main) {
                when (type) {
                    "new_episode" -> {
                        showNewEpisodeNotification(
                            seriesTitle = data["series_title"] ?: "Unknown Series",
                            episodeTitle = data["episode_title"] ?: "New Episode",
                            contentId = data["content_id"],
                            thumbnailUrl = data["thumbnail_url"]
                        )
                    }
                    "new_season" -> {
                        showNewSeasonNotification(
                            seriesTitle = data["series_title"] ?: "Unknown Series",
                            seasonNumber = data["season_number"] ?: "1",
                            contentId = data["content_id"]
                        )
                    }
                    "weekly_digest" -> {
                        showWeeklyDigestNotification(
                            newEpisodesCount = data["new_episodes_count"]?.toIntOrNull() ?: 0,
                            newSeasonsCount = data["new_seasons_count"]?.toIntOrNull() ?: 0
                        )
                    }
                    else -> {
                        Log.w(TAG, "Unknown notification type: $type")
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error handling FCM data message: ${e.message}", e)
            // M4: Log to Crashlytics
            FirebaseCrashlytics.getInstance().apply {
                log("FCM data message handling failed for type: $type")
                recordException(e)
            }
        }
    }

    /**
     * Check if notification should be shown based on preferences and quiet hours
     */
    private suspend fun shouldShowNotification(type: String): Boolean {
        val preferences = database.notificationPreferencesDao().getPreferencesOnce()
            ?: return true // Default to showing if no preferences set

        // Check type-specific preference
        val typeEnabled = when (type) {
            "new_episode" -> preferences.newEpisodesEnabled
            "new_season" -> preferences.newSeasonsEnabled
            "weekly_digest" -> preferences.weeklyDigestEnabled
            else -> false
        }

        if (!typeEnabled) {
            return false
        }

        // Check quiet hours
        val currentHour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY)
        val isQuietHour = notificationHelper.isQuietHour(
            currentHour,
            preferences.quietHoursStart,
            preferences.quietHoursEnd
        )

        return !isQuietHour
    }

    /**
     * Show notification for new episode
     */
    private fun showNewEpisodeNotification(
        seriesTitle: String,
        episodeTitle: String,
        contentId: String?,
        thumbnailUrl: String?
    ) {
        val intent = Intent(this, VideoPlayerActivity::class.java).apply {
            contentId?.let { putExtra("CONTENT_ID", it) }
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
        }

        val pendingIntent = PendingIntent.getActivity(
            this,
            NOTIFICATION_ID_NEW_EPISODE,
            intent,
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        )

        val notification = NotificationCompat.Builder(this, CHANNEL_ID_NEW_EPISODES)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("New Episode: $seriesTitle")
            .setContentText(episodeTitle)
            .setStyle(NotificationCompat.BigTextStyle().bigText(episodeTitle))
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .build()

        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.notify(NOTIFICATION_ID_NEW_EPISODE, notification)

        Log.d(TAG, "New episode notification shown: $seriesTitle - $episodeTitle")
    }

    /**
     * Show notification for new season
     */
    private fun showNewSeasonNotification(
        seriesTitle: String,
        seasonNumber: String,
        contentId: String?
    ) {
        val intent = Intent(this, VideoPlayerActivity::class.java).apply {
            contentId?.let { putExtra("CONTENT_ID", it) }
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
        }

        val pendingIntent = PendingIntent.getActivity(
            this,
            NOTIFICATION_ID_NEW_SEASON,
            intent,
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        )

        val notification = NotificationCompat.Builder(this, CHANNEL_ID_NEW_SEASONS)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("New Season Available!")
            .setContentText("$seriesTitle - Season $seasonNumber")
            .setStyle(
                NotificationCompat.BigTextStyle()
                    .bigText("Season $seasonNumber of $seriesTitle is now available to watch!")
            )
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .build()

        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.notify(NOTIFICATION_ID_NEW_SEASON, notification)

        Log.d(TAG, "New season notification shown: $seriesTitle - Season $seasonNumber")
    }

    /**
     * Show weekly digest notification
     */
    private fun showWeeklyDigestNotification(
        newEpisodesCount: Int,
        newSeasonsCount: Int
    ) {
        if (newEpisodesCount == 0 && newSeasonsCount == 0) {
            return // Nothing to show
        }

        val intent = Intent(this, VideoPlayerActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
        }

        val pendingIntent = PendingIntent.getActivity(
            this,
            NOTIFICATION_ID_WEEKLY_DIGEST,
            intent,
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        )

        val contentText = buildString {
            if (newEpisodesCount > 0) {
                append("$newEpisodesCount new episodes")
            }
            if (newSeasonsCount > 0) {
                if (newEpisodesCount > 0) append(" and ")
                append("$newSeasonsCount new seasons")
            }
            append(" this week!")
        }

        val notification = NotificationCompat.Builder(this, CHANNEL_ID_WEEKLY_DIGEST)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("Weekly Digest - FarsilandTV")
            .setContentText(contentText)
            .setStyle(NotificationCompat.BigTextStyle().bigText(contentText))
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .build()

        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.notify(NOTIFICATION_ID_WEEKLY_DIGEST, notification)

        Log.d(TAG, "Weekly digest notification shown: $contentText")
    }

    /**
     * Create notification channels (Android O+)
     */
    private fun createNotificationChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channels = listOf(
                NotificationChannel(
                    CHANNEL_ID_NEW_EPISODES,
                    "New Episodes",
                    NotificationManager.IMPORTANCE_DEFAULT
                ).apply {
                    description = "Notifications for new episodes in your monitored series"
                },
                NotificationChannel(
                    CHANNEL_ID_NEW_SEASONS,
                    "New Seasons",
                    NotificationManager.IMPORTANCE_DEFAULT
                ).apply {
                    description = "Notifications for new seasons of your favorite series"
                },
                NotificationChannel(
                    CHANNEL_ID_WEEKLY_DIGEST,
                    "Weekly Digest",
                    NotificationManager.IMPORTANCE_LOW
                ).apply {
                    description = "Weekly summary of new content"
                }
            )

            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            channels.forEach { notificationManager.createNotificationChannel(it) }

            Log.d(TAG, "Notification channels created")
        }
    }
}
