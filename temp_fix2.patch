--- a/app/src/main/java/com/example/farsilandtv/data/repository/ContentRepository.kt
+++ b/app/src/main/java/com/example/farsilandtv/data/repository/ContentRepository.kt
@@ -1053,59 +1053,52 @@
     }

     /**
-     * Get movies by multiple genres (OR logic - matches ANY selected genre)
+     * DEEP AUDIT FIX: Database-only filtering with proper pagination
+     *
+     * Previous Issue: Fetched 100 items from API, filtered client-side
+     * Result: Page 2 might have 0 matches â†’ infinite scroll breaks
+     *
+     * New Approach: Use database-only filtering with LIMIT/OFFSET
+     * Why: Database is synced every 30min, has all content, supports proper pagination
+     *
      * @param genres List of Genre enums to filter by
      * @param page Page number (starts from 1)
-     * @return Flow of movies matching any of the selected genres
+     * @param perPage Items per page (default 20)
+     * @return List of movies matching any of the selected genres
      */
-    suspend fun getMoviesByGenres(genres: List<com.example.farsilandtv.data.model.Genre>, page: Int = 1): Result<List<Movie>> =
-        withContext(Dispatchers.IO) {
-            try {
-                if (genres.isEmpty()) {
-                    // No genres selected - return all movies
-                    return@withContext getMovies(page, perPage = 20)
-                }
-
-                // Try API first - fetch movies and filter by genre
-                ensureActive()
-                val allMovies = getMovies(page, perPage = 100).getOrNull() ?: emptyList()
-                ensureActive()
-
-                // Filter movies that contain ANY of the selected genres (OR logic)
-                val genreNames = genres.map { it.englishName.lowercase() }
-                val filteredMovies = allMovies.filter { movie ->
-                    movie.genres.any { movieGenre ->
-                        genreNames.contains(movieGenre.lowercase())
-                    }
-                }
-
-                Result.success(filteredMovies)
-            } catch (e: Exception) {
-                e.printStackTrace()
-
-                // Fallback to database if API fails
-                try {
-                    ensureActive()
-                    val genreNames = genres.map { it.englishName }
-                    val cachedMovies = mutableListOf<CachedMovie>()
-
-                    // Query database for each genre and combine results
-                    for (genreName in genreNames) {
-                        val movies = getContentDb().movieDao().getMoviesByGenre(genreName).firstOrNull()
-                        movies?.let { cachedMovies.addAll(it) }
-                    }
-
-                    ensureActive()
-                    if (cachedMovies.isNotEmpty()) {
-                        // Remove duplicates and convert to Movie objects
-                        val uniqueMovies = cachedMovies.distinctBy { it.id }.map { it.toMovie() }
-                        return@withContext Result.success(uniqueMovies)
-                    }
-                } catch (dbError: Exception) {
-                    dbError.printStackTrace()
-                }
-
-                Result.failure(e)
+    suspend fun getMoviesByGenres(
+        genres: List<com.example.farsilandtv.data.model.Genre>,
+        page: Int = 1,
+        perPage: Int = 20
+    ): Result<List<Movie>> = withContext(Dispatchers.IO) {
+        try {
+            if (genres.isEmpty()) {
+                // No filter - use existing method
+                return@withContext getMovies(page, perPage)
             }
+
+            // DEEP AUDIT FIX: Use database-only filtering (no API calls)
+            val genreNames = genres.map { it.englishName }
+            val sanitizedGenres = genreNames.map { SqlSanitizer.sanitizeLikePattern(it) }
+
+            // Pad genres list to 5 elements (DAO expects up to 5)
+            val genre1 = sanitizedGenres.getOrNull(0) ?: return@withContext Result.success(emptyList())
+            val genre2 = sanitizedGenres.getOrNull(1)
+            val genre3 = sanitizedGenres.getOrNull(2)
+            val genre4 = sanitizedGenres.getOrNull(3)
+            val genre5 = sanitizedGenres.getOrNull(4)
+
+            val offset = (page - 1) * perPage
+
+            // Single database query with proper pagination
+            val cachedMovies = getContentDb().movieDao().getMoviesByGenresPaginated(
+                genre1 = genre1,
+                genre2 = genre2,
+                genre3 = genre3,
+                genre4 = genre4,
+                genre5 = genre5,
+                limit = perPage,
+                offset = offset
+            )
+
+            // Convert to Movie objects
+            val movies = cachedMovies.map { it.toMovie() }
+            Result.success(movies)
+        } catch (e: Exception) {
+            handleApiError("getMoviesByGenres(genres=${genres.size}, page=$page)", e)
         }
+    }
